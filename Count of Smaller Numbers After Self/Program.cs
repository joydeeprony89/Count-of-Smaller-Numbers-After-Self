using System;
using System.Collections.Generic;

namespace Count_of_Smaller_Numbers_After_Self
{
    class Program
    {
        static void Main(string[] args)
        {
            Program p = new Program();
            var nums = new int[] { 5, 3, 2, 6, 4, 1 }; // 9 , 11, 15, 2, 5, 6
            Console.WriteLine(string.Join(" ", p.CountSmaller(nums)));
        }

        // Wrapper class for each and every value of the input array,
        // to store the original index position of each value, before we merge sort the array
        private class ArrayValWithOrigIdx
        {
            public int val;
            public int originalIdx;

            public ArrayValWithOrigIdx(int val, int originalIdx)
            {
                this.val = val;
                this.originalIdx = originalIdx;
            }
        }

        public List<int> CountSmaller(int[] nums)
        {
            if (nums == null || nums.Length == 0) return new List<int>();
            int n = nums.Length;
            int[] result = new int[n];

            ArrayValWithOrigIdx[] newNums = new ArrayValWithOrigIdx[n];
            for (int i = 0; i < n; ++i) newNums[i] = new ArrayValWithOrigIdx(nums[i], i);

            MergeSortAndCount(newNums, 0, n - 1, result);

            // notice we don't care about the sorted array after merge sort finishes.
            // we only wanted the result counts, generated by running merge sort
            List<int> resultList = new List<int>();
            foreach (int i in result) resultList.Add(i);
            return resultList;
        }

        static void MergeSortAndCount(ArrayValWithOrigIdx[] nums, int start, int end, int[] result)
        {
            if (start >= end) return;

            int mid = (start + end) / 2;
            MergeSortAndCount(nums, start, mid, result);
            MergeSortAndCount(nums, mid + 1, end, result);

            // left subarray start...mid
            // right subarray mid+1...end
            int leftPos = start;
            int rightPos = mid + 1;
            LinkedList<ArrayValWithOrigIdx> merged = new LinkedList<ArrayValWithOrigIdx>();
            int numElemsRightArrayLessThanLeftArray = 0;
            while (leftPos < mid + 1 && rightPos <= end)
            {
                if (nums[leftPos].val > nums[rightPos].val)
                {
                    // this code block is exactly what the problem is asking us for:
                    // a number from the right side of the original input array, is smaller
                    // than a number from the left side
                    //
                    // within this code block,
                    // nums[rightPos] is smaller than the start of the left sub-array.
                    // Since left sub-array is already sorted,
                    // nums[rightPos] must also be smaller than the entire remaining left sub-array
                    ++numElemsRightArrayLessThanLeftArray;

                    // continue with normal merge sort, merge
                    merged.AddLast(nums[rightPos]);
                    ++rightPos;
                }
                else
                {
                    // a number from left side of array, is smaller than a number from
                    // right side of array
                    result[nums[leftPos].originalIdx] += numElemsRightArrayLessThanLeftArray;

                    // Continue with normal merge sort
                    merged.AddLast(nums[leftPos]);
                    ++leftPos;
                }
            }

            // part of normal merge sort, if either left or right sub-array is not empty,
            // move all remaining elements into merged result
            while (leftPos < mid + 1)
            {
                result[nums[leftPos].originalIdx] += numElemsRightArrayLessThanLeftArray;

                merged.AddLast(nums[leftPos]);
                ++leftPos;
            }
            while (rightPos <= end)
            {
                merged.AddLast(nums[rightPos]);
                ++rightPos;
            }

            // part of normal merge sort
            // copy back merged result into array
            int pos = start;
            foreach (ArrayValWithOrigIdx m in merged)
            {
                nums[pos] = m;
                ++pos;
            }
        }
    }
}
